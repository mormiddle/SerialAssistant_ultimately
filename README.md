# 1.2 

- 完成十通道波形图布局，优化界面显示
- 完成y轴自适应变化
- 初始化所有波形图，构造初始化显示
  不完善，使用了太多全局list，占用空间，预计使用函数进行list拆分

## 1.3 加入校验机制

- 帧头为`0xAA`，帧尾为`0x80`，长度为`0x2C`

- 协议为：帧头 + 长度 + 数据 + 校验位1 + 校验位2  + 帧尾

  ```c
  crcm = crc32(data, 40);
  crc1 = crcm >> 16; //校验位1
  crc2 = crcm & 0xFFFF; //校验位2
  ```

- 完成完整一帧的校验，获得去除帧头，长度，帧尾的数据+校验位（44字节）

### 出现的问题

1. 串口的输入模式需要是HEX，同样的接口模式也要选择HEX

2. 再输入两段数据时，串口助手显示三段数据
   即输入` AA 2C DATA1 80 AA 2C DATA2 80`
   理论输出：`DATA1 DATA2`
   实际输出：`DATA1 DATA1 DATA2`
   原因：第一段输入之后，虽然接受缓存区的数组中已经删除了第一段数据，但是串口缓存区的还未删除第一段的数据。故，当第二段数据输入是，缓存区还有第一段的数据，造成了这种情况。
   解决方案：` private StringBuilder sb = new StringBuilder(); //为了避免在接收处理函数中反复调用，依然声明为一个全局变量`  在每次调用数据接受函数时，使用`sb.clear();`来清空缓存区

## 1.4 加入crc8校验

- 修改校验机制
  帧头为`0xAA`，帧尾为`0x80`，长度为`0x29`

- 协议为：帧头 + 长度 + 数据 + 校验位 + 帧尾
  ```c
  crcm = crc8(wait trans,40);
  usartldataTrans8(crcm);
  ```

- 完成完整一帧的校验，获得去除帧头，长度，帧尾的数据+校验位（41字节）

### 出现的问题

- crc8校验函数，输出的是16进制的byte，而serialPort1.Read将读取到的16进制byte转换为10进制
- 解决方案：在crc8校验函数后面加入转化，转换为10进制byte

## 1.5 CRC8校验优化，波形图修改

- 使用单片机测试，发现crc8校验依然存在问题，校验位和单片机计算有差异
- 将多个通道的波形，放在同一个图标中，只用两个chart图标完成波形显示

## 1.6 内存不足和线程占用优化

- 持续接受一分钟之后，内存不足崩溃
- 同时有虚部和实部数据，内存申请太多崩溃
- 将实部和虚部整合，然后再输出，同时更改波形图绘制逻辑

## 1.7 实现十路波形绘制

- 原有的波形绘制函数基于list数列，对于多通道并不友好
- 按数据位中每两个字节为一个数，作为波形绘制的y轴，就可以实现十路波形的绘制
- 最简单的方法往往最有效
